<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>FunctionSelect - com.ligadata.Compiler.FunctionSelect</title>
          <meta name="description" content="FunctionSelect - com.ligadata.Compiler.FunctionSelect" />
          <meta name="keywords" content="FunctionSelect com.ligadata.Compiler.FunctionSelect" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'com.ligadata.Compiler.FunctionSelect';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/class_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="com">com</a>.<a href="../package.html" class="extype" name="com.ligadata">ligadata</a>.<a href="package.html" class="extype" name="com.ligadata.Compiler">Compiler</a></p>
        <h1>FunctionSelect</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">FunctionSelect</span><span class="result"> extends <a href="LogTrait.html" class="extype" name="com.ligadata.Compiler.LogTrait">LogTrait</a></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p> 1) Build a function typestring from the apply node and its children (function arguments) to locate the appropriate
 function in the metadata.
 2) Determine the return type for this function.  Use it to update the parent derived field (if needed).
 	a) If this function is Iterable the first argument will be considered the receiver, the second a function
  		that operates on the Iterables elements and the remaining arguments used to select the function
  		filter, map, retain ... etc function.
     b) For map functions where the return type of the Iterable returned is different than the receiver, the
     	type will be inferred from the transformation function used on each element.</p><p>      	For example, consider this map function that converts an array inpatient claims (a struct) to an array of doubles</p><p>       		&lt;DerivedField name=&quot;OutClaimIcd9DgnsFilter&quot; dataType=&quot;Array&quot; optype=&quot;categorical&quot;&gt;
         		&lt;Apply function=&quot;ContainerMap&quot;&gt;
           			&lt;FieldRef field=&quot;inPatientClaims&quot;/&gt;
              		&lt;Constant dataType=&quot;fIdent&quot;&gt;Sum&lt;/Constant&gt;
                		&lt;Constant dataType=&quot;ident&quot;&gt;Clm_Pmt_Amt&lt;/Constant&gt;
                  	&lt;Constant dataType=&quot;ident&quot;&gt;Nch_Prmry_Pyr_Clm_Pd_Amt&lt;/Constant&gt;
                   	&lt;Constant dataType=&quot;ident&quot;&gt;Nch_Bene_Blood_Ddctbl_Lblty_Am&lt;/Constant&gt;
                    	&lt;Constant dataType=&quot;ident&quot;&gt;Nch_Bene_Ptb_Ddctbl_Amt&lt;/Constant&gt;
                     &lt;Constant dataType=&quot;ident&quot;&gt;Nch_Bene_Ptb_Coinsrnc_Amt&lt;/Constant&gt;
                     &lt;Constant dataType=&quot;integer&quot;&gt;1&lt;/Constant&gt;
                 &lt;/Apply&gt;
             &lt;/DerivedField&gt;</p><p>          A function key for the &quot;fIdent&quot;, Sum, would be prepared consisting of &quot;Sum(double,double,double,double,double,integer)&quot;
          If there is not an exact match, a new key will be prepared that relaxes the argument types as necesary.  In this case
          the new key would be &quot;Sum(double,double,double,double,double,double)&quot;.  If that fails, we are done, complaining about
          the lack of a suitable function for this usage.</p><p>          Obviously the degree of sophistication employed for determining a matching type can be complex.  The &quot;implicit&quot;-ness
          used to infer the proper function and its types will be a continuing improvement project.
	c) When the function is not iterable all arguments are treated as arguments to the named apply function
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="LogTrait.html" class="extype" name="com.ligadata.Compiler.LogTrait">LogTrait</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="com.ligadata.Compiler.FunctionSelect"><span>FunctionSelect</span></li><li class="in" name="com.ligadata.Compiler.LogTrait"><span>LogTrait</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="com.ligadata.Compiler.FunctionSelect#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(ctx:com.ligadata.Compiler.PmmlContext,mgr:com.ligadata.olep.metadata.MdMgr,node:com.ligadata.Compiler.xApply):com.ligadata.Compiler.FunctionSelect"></a>
      <a id="&lt;init&gt;:FunctionSelect"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">FunctionSelect</span><span class="params">(<span name="ctx">ctx: <a href="PmmlContext.html" class="extype" name="com.ligadata.Compiler.PmmlContext">PmmlContext</a></span>, <span name="mgr">mgr: <a href="../olep/metadata/MdMgr.html" class="extype" name="com.ligadata.olep.metadata.MdMgr">MdMgr</a></span>, <span name="node">node: <a href="xApply.html" class="extype" name="com.ligadata.Compiler.xApply">xApply</a></span>)</span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#FunctionKeysThatWouldMatch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FunctionKeysThatWouldMatch(name:String):Array[String]"></a>
      <a id="FunctionKeysThatWouldMatch(String):Array[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">FunctionKeysThatWouldMatch</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Answer an array of function keys that could match a specific version
 of a function that has this simple function name (or namespace qualified name).</p><div class="fullcomment"><div class="comment cmt"><p> Answer an array of function keys that could match a specific version
 of a function that has this simple function name (or namespace qualified name).
</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>: the function name search key to locate the functions that
 	available with this name.</p></dd><dt>returns</dt><dd class="cmt"><p>the search keys that could be used to locate an
</p></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#buildIterableKey" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buildIterableKey(buildElementFcnKey:Boolean,fcnName:String,argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],containerType:com.ligadata.olep.metadata.ContainerTypeDef,collectionsElementTypes:Array[com.ligadata.olep.metadata.BaseTypeDef]):String"></a>
      <a id="buildIterableKey(Boolean,String,Array[(String,Boolean,BaseTypeDef)],ContainerTypeDef,Array[BaseTypeDef]):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buildIterableKey</span><span class="params">(<span name="buildElementFcnKey">buildElementFcnKey: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="fcnName">fcnName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>, <span name="containerType">containerType: <a href="../olep/metadata/ContainerTypeDef.html" class="extype" name="com.ligadata.olep.metadata.ContainerTypeDef">ContainerTypeDef</a></span>, <span name="collectionsElementTypes">collectionsElementTypes: <span class="extype" name="scala.Array">Array</span>[<a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> One or more functions with node.</p><div class="fullcomment"><div class="comment cmt"><p> One or more functions with node.function as name exists and has been
 determined to be an &quot;Iterable&quot; function.  This means that any of the
 functions with this name must be &quot;Iterable&quot; and as such we build two
 keys for both the element function and the Iterable function that uses
 it.  Supply the correct boolean value to choose which should be built.</p><p> When building element function key, there are these cases:</p><ul><li>If there is no fIdent then the remaining arguments are any of these:</li><li>standard constants</li><li>field refs</li><li>field identifiers ('ident' constants) for the Iterable collection item (first arg of the apply)</li><li>With an fIdent present, then the remaining arguments are interpreted this way:</li><li>if the fIdent is a simple function all arguments are used to build the key</li><li>if the fIdent is an 'Iterable', then only the first argument of the arg keys is used</li></ul><p> When there is an element function that is 'Iterable', recognize the elements of the parent
 container of the outer 'Iterable' function are some kind of collection (or should be). The
 Iterable collection for the member function is specified with the mapping variable, namely
 &quot;_each&quot;.  Currently only field ('ident') projections from the member array, constants, and
 fieldrefs are supported for the subsequent argument.</p><p> FIXME: No 'fIdent' support at this point for 'Iterable' mbr functions (i.e., Iterable mbr
 function that would have its own mbr function)</p><p> When building the 'Iterable' function key, only the collection in arg 1 is used for the
 function signature.  The remaining arguments either refer to a member function and args
 or simply a list of args (typically a 'map' operation) that is used to build a tuple
 from the collection struct names ('ident' constants), field refs or other standard constant values.</p><p> Iterable function keys look like this:</p><p> 	ContainerFilter(scala.collection.mutable.Array[Any]
</p></div><dl class="paramcmts block"><dt class="param">buildElementFcnKey</dt><dd class="cmt"><p>- when true the element function key is built else the primary function key</p></dd><dt class="param">argTypes</dt><dd class="cmt"><p>- the argument type info for all elements specified in the pmml apply arg list.</p></dd><dt class="param">containerType</dt><dd class="cmt"><p>- the type info for the iterable's collection</p></dd><dt class="param">collectionsElementTypes</dt><dd class="cmt"><p>- the member(s) type info for the iterable's collection</p></dd><dt>returns</dt><dd class="cmt"><p>a search key to be used to search for the function in the metadata
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#buildSimpleKey" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buildSimpleKey(fcnName:String,argtypes:Array[String]):String"></a>
      <a id="buildSimpleKey(String,Array[String]):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buildSimpleKey</span><span class="params">(<span name="fcnName">fcnName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="argtypes">argtypes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a type string from the key, sans namespace
</p><div class="fullcomment"><div class="comment cmt"><p>Create a type string from the key, sans namespace
</p></div><dl class="paramcmts block"><dt class="param">fcnName</dt><dd class="cmt"><p>- the name of the function</p></dd><dt class="param">argtypes</dt><dd class="cmt"><p>- the arg type info collected for the apply function</p></dd><dt>returns</dt><dd class="cmt"><p>a search key to be used to find the function in the metadata.
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#checkForMemberFcn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="checkForMemberFcn:Boolean"></a>
      <a id="checkForMemberFcn:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">checkForMemberFcn</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Check if the current iterable function has a member function (most do).</p><div class="fullcomment"><div class="comment cmt"><p> Check if the current iterable function has a member function (most do).  If not, the iterable function
 is doing a projection on one or more of some container of fields.
</p></div></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#collectArgKeys" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="collectArgKeys(expandCompoundFieldTypes:Boolean):Array[(Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],com.ligadata.olep.metadata.ContainerTypeDef,Array[com.ligadata.olep.metadata.BaseTypeDef],String)]"></a>
      <a id="collectArgKeys(Boolean):Array[(Array[(String,Boolean,BaseTypeDef)],Array[(String,Boolean,BaseTypeDef)],ContainerTypeDef,Array[BaseTypeDef],String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectArgKeys</span><span class="params">(<span name="expandCompoundFieldTypes">expandCompoundFieldTypes: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)], <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)], <a href="../olep/metadata/ContainerTypeDef.html" class="extype" name="com.ligadata.olep.metadata.ContainerTypeDef">ContainerTypeDef</a>, <span class="extype" name="scala.Array">Array</span>[<a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>], <span class="extype" name="scala.Predef.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Collect the child arguments for simple function.</p>
    </li><li name="com.ligadata.Compiler.FunctionSelect#collectCollectionElementSuperClasses" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collectCollectionElementSuperClasses(argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]):scala.collection.mutable.Map[String,Array[Array[List[(String,reflect.runtime.universe.ClassSymbol,reflect.runtime.universe.Type)]]]]"></a>
      <a id="collectCollectionElementSuperClasses(Array[(String,Boolean,BaseTypeDef)]):Map[String,Array[Array[List[(String,scala.reflect.api.JavaUniverse.ClassSymbol,scala.reflect.api.JavaUniverse.Type)]]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectCollectionElementSuperClasses</span><span class="params">(<span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>)</span><span class="result">: <span class="extype" name="scala.collection.mutable.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.List">List</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.reflect.api.Symbols.ClassSymbol">scala.reflect.api.JavaUniverse.ClassSymbol</span>, <span class="extype" name="scala.reflect.api.Types.Type">scala.reflect.api.JavaUniverse.Type</span>)]]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> For ContainerTypeDefs that have an element or elements, determine which of them have container members.</p><div class="fullcomment"><div class="comment cmt"><p> For ContainerTypeDefs that have an element or elements, determine which of them have container members.
 Make an array of their superclasses similar to collectContainerSuperClasses.  Since there can be more
 than one element type used to specify a collection, and furthermore each element could itself be a
 collection with member types, ad finitum, answer a map with an array of array of a list oftriples as value -
 one array of array for each collection element type.
</p></div><dl class="paramcmts block"><dt class="param">argTypes</dt><dd class="cmt"><p>(the type (class) name for the container, if it is a container, the metadata for this type)</p></dd><dt>returns</dt><dd class="cmt"><p>a Map[String, Array[Array[List[(String, ClassSymbol, Type)]]]] where the key is the typename,
 	for each element container type.  If the element is not a container or there are no containers in the args supplied,
  	answer nulls as needed
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#collectContainerSuperClasses" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collectContainerSuperClasses(argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]):scala.collection.mutable.Map[String,Array[(String,reflect.runtime.universe.ClassSymbol,reflect.runtime.universe.Type)]]"></a>
      <a id="collectContainerSuperClasses(Array[(String,Boolean,BaseTypeDef)]):Map[String,Array[(String,scala.reflect.api.JavaUniverse.ClassSymbol,scala.reflect.api.JavaUniverse.Type)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectContainerSuperClasses</span><span class="params">(<span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>)</span><span class="result">: <span class="extype" name="scala.collection.mutable.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.reflect.api.Symbols.ClassSymbol">scala.reflect.api.JavaUniverse.ClassSymbol</span>, <span class="extype" name="scala.reflect.api.Types.Type">scala.reflect.api.JavaUniverse.Type</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> For any ContainerTypesDefs, collect the super classes for each one in the argTypes.</p><div class="fullcomment"><div class="comment cmt"><p> For any ContainerTypesDefs, collect the super classes for each one in the argTypes.  Answer an array
 of (type name, class symbol, type symbol) triples for each superclass) for each arg type.
</p></div><dl class="paramcmts block"><dt class="param">argTypes</dt><dd class="cmt"><p>(the type (class) name for the container, if it is a container, the metadata for this type)</p></dd><dt>returns</dt><dd class="cmt"><p>for each argType an array that consists of (type, class symbol, type symbol)
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#collectIterableArgKeys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collectIterableArgKeys(expandCompoundFieldTypes:Boolean):Array[(Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],com.ligadata.olep.metadata.ContainerTypeDef,Array[com.ligadata.olep.metadata.BaseTypeDef],String)]"></a>
      <a id="collectIterableArgKeys(Boolean):Array[(Array[(String,Boolean,BaseTypeDef)],Array[(String,Boolean,BaseTypeDef)],ContainerTypeDef,Array[BaseTypeDef],String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectIterableArgKeys</span><span class="params">(<span name="expandCompoundFieldTypes">expandCompoundFieldTypes: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)], <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)], <a href="../olep/metadata/ContainerTypeDef.html" class="extype" name="com.ligadata.olep.metadata.ContainerTypeDef">ContainerTypeDef</a>, <span class="extype" name="scala.Array">Array</span>[<a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>], <span class="extype" name="scala.Predef.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Collect the child arguments for an iterable function.</p><div class="fullcomment"><div class="comment cmt"><p>Collect the child arguments for an iterable function. These functions are typically comprised of two functions
 the collection function (e.g., filter, map, etc.) and the element function (a function that operates on
 one or more fields of the collection specified in arg 1.</p><p> As a consequence, there are two argType triples returned, one for the outer function (map, filter, etc.) and
 one for the inner function that operates on the iterable function.</p><p> As a consequence, the first array element in the array returned will have just one type triple - namely for the
 iterable collection reference.  The second element will have type triples for the remaining pmml arguments to this
 iterable function.  The fIdent element, if present is skipped.  It will be located and used by the key preparation
 function for iterables.
</p></div></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#constantArgForIterableFcn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="constantArgForIterableFcn(constNode:com.ligadata.Compiler.xConstant,expandCompoundFieldTypes:Boolean,containerType:com.ligadata.olep.metadata.ContainerTypeDef,collectionsElementTypes:Array[com.ligadata.olep.metadata.BaseTypeDef]):Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]"></a>
      <a id="constantArgForIterableFcn(xConstant,Boolean,ContainerTypeDef,Array[BaseTypeDef]):Array[(String,Boolean,BaseTypeDef)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">constantArgForIterableFcn</span><span class="params">(<span name="constNode">constNode: <a href="xConstant.html" class="extype" name="com.ligadata.Compiler.xConstant">xConstant</a></span>, <span name="expandCompoundFieldTypes">expandCompoundFieldTypes: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="containerType">containerType: <a href="../olep/metadata/ContainerTypeDef.html" class="extype" name="com.ligadata.olep.metadata.ContainerTypeDef">ContainerTypeDef</a></span>, <span name="collectionsElementTypes">collectionsElementTypes: <span class="extype" name="scala.Array">Array</span>[<a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Discover the typestring for the supplied constant that is an argument for
 a function (i.</p><div class="fullcomment"><div class="comment cmt"><p> Discover the typestring for the supplied constant that is an argument for
 a function (i.e., ordinarily not Iterable).  HOWEVER, the member function, should it exist,
 may be an iterable function itself (e.g., typical situation interpreting groupBy map's values).</p><p> When this is the case, the containerType is a collection that has an element type that is a collection.
 This possibility is considered before &quot;field not found&quot; error is issued.
</p></div></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#constantKeyForSimpleNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="constantKeyForSimpleNode(constNode:com.ligadata.Compiler.xConstant,expandCompoundFieldTypes:Boolean):Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]"></a>
      <a id="constantKeyForSimpleNode(xConstant,Boolean):Array[(String,Boolean,BaseTypeDef)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">constantKeyForSimpleNode</span><span class="params">(<span name="constNode">constNode: <a href="xConstant.html" class="extype" name="com.ligadata.Compiler.xConstant">xConstant</a></span>, <span name="expandCompoundFieldTypes">expandCompoundFieldTypes: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Discover the typestring for the supplied constant that is an argument for
 a simple function (i.</p><div class="fullcomment"><div class="comment cmt"><p> Discover the typestring for the supplied constant that is an argument for
 a simple function (i.e., not Iterable).
</p></div></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#ctx" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ctx:com.ligadata.Compiler.PmmlContext"></a>
      <a id="ctx:PmmlContext"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ctx</span><span class="result">: <a href="PmmlContext.html" class="extype" name="com.ligadata.Compiler.PmmlContext">PmmlContext</a></span>
      </span>
      </h4>
      
    </li><li name="com.ligadata.Compiler.FunctionSelect#determineMapReturnElementTypes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="determineMapReturnElementTypes(mbrFuncDef:com.ligadata.olep.metadata.FunctionDef,mbrsArgTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]):String"></a>
      <a id="determineMapReturnElementTypes(FunctionDef,Array[(String,Boolean,BaseTypeDef)]):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">determineMapReturnElementTypes</span><span class="params">(<span name="mbrFuncDef">mbrFuncDef: <a href="../olep/metadata/FunctionDef.html" class="extype" name="com.ligadata.olep.metadata.FunctionDef">FunctionDef</a></span>, <span name="mbrsArgTypes">mbrsArgTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Answer the return types to use for a collection being created by some function through a map (or similar) transformative
 operation.</p><div class="fullcomment"><div class="comment cmt"><p> Answer the return types to use for a collection being created by some function through a map (or similar) transformative
 operation.  There are two cases:</p><ul><li>When there is a member function present (there is an fIdent constant type denoting the fcn name), use the function definition's
 	return type.  This determination is made in the caller.  Here we simply see if there is a metadata typedef for the function.</li><li>When there is NO member function present, the return type is based upon the free arguments in the mbrsArgTypes.  Typically there
 	is one argument, however if there are multiple arguments, a tuple type is formed from the arg metadata.</li></ul></div><dl class="paramcmts block"><dt class="param">mbrFuncDef</dt><dd class="cmt"><p>- the metadata for the iterable's member function.  If null the mbrArgTypes will be used to form the return element types</p></dd><dt class="param">mbrsArgTypes</dt><dd class="cmt"><p>- and array of the type info triples (typeStr, isContainerWithFields, typeInfo metadata) for the member function
 	arguments (or the args to be used in a projection of a structure or mapped base container)</p></dd><dt>returns</dt><dd class="cmt"><p>memberType string to be used as part of the return type for some iterable collection being iterated.
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#encloseElementArgs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="encloseElementArgs(typeString:String,openBracketOrParen:Char,closeBracketOrParen:Char):String"></a>
      <a id="encloseElementArgs(String,Char,Char):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">encloseElementArgs</span><span class="params">(<span name="typeString">typeString: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="openBracketOrParen">openBracketOrParen: <span class="extype" name="scala.Char">Char</span></span>, <span name="closeBracketOrParen">closeBracketOrParen: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Extract the text between the two specified characters from the supplied string.</p><div class="fullcomment"><div class="comment cmt"><p> Extract the text between the two specified characters from the supplied string.  The characters supplied are
 assumed to be matching pairs.  This function handles nested bracketed types for example like this:
 	Array[Array[StructureOfSomeKind]]
 The function will return 'Array[StructureOfSomeKind]'
</p></div></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#fcnArgKey" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fcnArgKey(fcnNode:com.ligadata.Compiler.xApply):(String,com.ligadata.olep.metadata.FunctionDef,Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],com.ligadata.olep.metadata.FunctionDef,Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],com.ligadata.olep.metadata.ContainerTypeDef,Array[com.ligadata.olep.metadata.BaseTypeDef])"></a>
      <a id="fcnArgKey(xApply):(String,FunctionDef,Array[(String,Boolean,BaseTypeDef)],FunctionDef,Array[(String,Boolean,BaseTypeDef)],ContainerTypeDef,Array[BaseTypeDef])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fcnArgKey</span><span class="params">(<span name="fcnNode">fcnNode: <a href="xApply.html" class="extype" name="com.ligadata.Compiler.xApply">xApply</a></span>)</span><span class="result">: (<span class="extype" name="scala.Predef.String">String</span>, <a href="../olep/metadata/FunctionDef.html" class="extype" name="com.ligadata.olep.metadata.FunctionDef">FunctionDef</a>, <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)], <a href="../olep/metadata/FunctionDef.html" class="extype" name="com.ligadata.olep.metadata.FunctionDef">FunctionDef</a>, <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)], <a href="../olep/metadata/ContainerTypeDef.html" class="extype" name="com.ligadata.olep.metadata.ContainerTypeDef">ContainerTypeDef</a>, <span class="extype" name="scala.Array">Array</span>[<a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>])</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Discover the typestring for the supplied Apply that is an argument for a simple function (i.</p><div class="fullcomment"><div class="comment cmt"><p> Discover the typestring for the supplied Apply that is an argument for a simple function (i.e., not Iterable).
 Of interest here is the return type of the function.  For the simple functions, this is relatively straight forward.
 For the iterable functions, it depends.  SOME of the factors:</p><ul><li>Filter, partition, and others return the same collection and member type as the iterable function's
 	receiver (i.e., the first apply arg)</li><li>The map (et al) functions are transformer functions that can return a different member type.
 	For example an array of arrays of ints (see example below) can change the member type where the collection does
  	not change.  However, it is also to actually return one of the collection's (superclass) traits.  In those
   	cases, the function implementation needs to add a cast to the original collection type to keep it simple.</li></ul><p>In same vein, only one member function will be allowed with the current implementation.  Its
    	return type will be used to change the collection's member type(or types)</p><ul><li>The groupBy function for example will take an array and split it into parts based upon some discriminator
 	function.  The result is a map! where the key is the group by value determined by the discriminator function
  	and the value is the elements of the array that share that value.</li></ul><p> To see the complexity involved resolving inferring the return type, consider this REPL session:</p><p> scala&gt; val a : Array[Int] = Array[Int](1,2,3,4,5)
 a: Array[Int] = Array(1, 2, 3, 4, 5)</p><p> scala&gt; val b  = a.map(_ * 2)
 b: Array[Int] = Array(2, 4, 6, 8, 10)</p><p> scala&gt; val c = b.map(_ + 2)
 c: Array[Int] = Array(4, 6, 8, 10, 12)</p><p> scala&gt; val composite = Array[Array[Int]](a,b,c)
 composite: Array[Array[Int]] = Array(Array(1, 2, 3, 4, 5), Array(2, 4, 6, 8, 10), Array(4, 6, 8, 10, 12))</p><p> scala&gt; composite.map(arr =&gt; arr.sum)  &lt;&lt;&lt; this kind of thing is common for aggregation
 res0: Array[Int] = Array(15, 30, 40)</p><p> scala&gt; composite.map(arr =&gt; arr(0) + arr(2))  &lt;&lt;&lt; this kind of thing is common for aggregation
 res1: Array[Int] = Array(4, 8, 12)</p><p> scala&gt; val z = a zip b
 z: Array[(Int, Int)] = Array((1,2), (2,4), (3,6), (4,8), (5,10))</p><p> scala&gt; val zMap = (a zip b).toMap
 zMap: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 10, 1 -&gt; 2, 2 -&gt; 4, 3 -&gt; 6, 4 -&gt; 8)</p><p> scala&gt; zMap.values
 res2: Iterable[Int] = MapLike(10, 2, 4, 6, 8)</p><p> scala&gt; zMap.values.toArray
 res3: Array[Int] = Array(10, 2, 4, 6, 8)</p><p> scala&gt; zMap.keys.toArray
 res4: Array[Int] = Array(5, 1, 2, 3, 4)</p><p> scala&gt; zMap.keys.toVector
 res5: Vector[Int] = Vector(5, 1, 2, 3, 4)</p><p> scala&gt; zMap.keys.toList
 res6: List[Int] = List(5, 1, 2, 3, 4)</p><p> scala&gt; zMap.toArray
 res7: Array[(Int, Int)] = Array((5,10), (1,2), (2,4), (3,6), (4,8)) &lt;&lt;&lt; map's k/v transforms to (k,v)</p><p> scala&gt; val s : Array[Int] = Array[Int](1,2,3,4,5,6,7,8,9,10)
 s: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</p><p> scala&gt; val kinds = s.groupBy {
 |    case itm if (itm &lt; 3) =&gt; &quot;one&quot;
 |    case itm if (itm &gt;= 3 &amp;&amp; itm &lt;= 6) =&gt; &quot;two&quot;
 |    case _ =&gt; &quot;other&quot;
 | }
 kinds: scala.collection.immutable.Map[String,Array[Int]] =
 		Map(one -&gt; Array(1, 2), two -&gt; Array(3, 4, 5, 6), other -&gt; Array(7, 8, 9, 10))</p><p> FIXME: Suffice it to say there are many nuances here.  This function and things revolving around
 the necessary type inference deserve there own source file and class.
</p></div><dl class="paramcmts block"><dt class="param">fcnNode</dt><dd class="cmt"><p>the pmml function node to be considered</p></dd><dt>returns</dt><dd class="cmt"><p>(the function return type, the function def for the function, the mbr function def if appropriate, the
 	the iterable function's collection type info if appropriate, the iterable function's member type(s) if
  	appropriate)</p></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#fldRefArgKey" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fldRefArgKey(fldNode:com.ligadata.Compiler.xFieldRef,expandCompoundFieldTypes:Boolean):Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]"></a>
      <a id="fldRefArgKey(xFieldRef,Boolean):Array[(String,Boolean,BaseTypeDef)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fldRefArgKey</span><span class="params">(<span name="fldNode">fldNode: <a href="xFieldRef.html" class="extype" name="com.ligadata.Compiler.xFieldRef">xFieldRef</a></span>, <span name="expandCompoundFieldTypes">expandCompoundFieldTypes: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Discover the typestring for the supplied FieldRef that is an argument for
 a simple function (i.</p><div class="fullcomment"><div class="comment cmt"><p> Discover the typestring for the supplied FieldRef that is an argument for
 a simple function (i.e., not Iterable).
</p></div></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#isIterableFcn" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="isIterableFcn(fcnName:String):Boolean"></a>
      <a id="isIterableFcn(String):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isIterableFcn</span><span class="params">(<span name="fcnName">fcnName: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
    </li><li name="com.ligadata.Compiler.FunctionSelect#isIterableFcn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isIterableFcn:Boolean"></a>
      <a id="isIterableFcn:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isIterableFcn</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Assess whether function has the ITERABLE feature.</p><div class="fullcomment"><div class="comment cmt"><p>Assess whether function has the ITERABLE feature.  The rule here is that if any function with this
 name has the ITERABLE feature, they ALL MUST HAVE it.</p></div></div>
    </li><li name="com.ligadata.Compiler.LogTrait#logger" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="logger:&lt;error&gt;"></a>
      <a id="logger:&lt;error&gt;"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">logger</span><span class="result">: &lt;error&gt;</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="LogTrait.html" class="extype" name="com.ligadata.Compiler.LogTrait">LogTrait</a></dd></dl></div>
    </li><li name="com.ligadata.Compiler.LogTrait#loggerName" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="loggerName:String"></a>
      <a id="loggerName:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">loggerName</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="LogTrait.html" class="extype" name="com.ligadata.Compiler.LogTrait">LogTrait</a></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#mgr" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="mgr:com.ligadata.olep.metadata.MdMgr"></a>
      <a id="mgr:MdMgr"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">mgr</span><span class="result">: <a href="../olep/metadata/MdMgr.html" class="extype" name="com.ligadata.olep.metadata.MdMgr">MdMgr</a></span>
      </span>
      </h4>
      
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#node" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="node:com.ligadata.Compiler.xApply"></a>
      <a id="node:xApply"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">node</span><span class="result">: <a href="xApply.html" class="extype" name="com.ligadata.Compiler.xApply">xApply</a></span>
      </span>
      </h4>
      
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#relaxCollectionMbrTypesToAny" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="relaxCollectionMbrTypesToAny(argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]):Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]"></a>
      <a id="relaxCollectionMbrTypesToAny(Array[(String,Boolean,BaseTypeDef)]):Array[(String,Boolean,BaseTypeDef)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxCollectionMbrTypesToAny</span><span class="params">(<span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> For ContainerTypeDefs that have an element or element (e.</p><div class="fullcomment"><div class="comment cmt"><p> For ContainerTypeDefs that have an element or element (e.g., Array[SomeBigStructure] that is a container type,
 change it to 'Any' (i.e., 'SomeBigStructure' to 'Any'), keeping the base collection the same (in the example
 'Array').
</p></div><dl class="paramcmts block"><dt class="param">argTypes</dt><dd class="cmt"><p>a triple of type information that describes the arguments to the function being considered
 	(type string, isContainerWithFields, the arg metadata)</p></dd><dt>returns</dt><dd class="cmt"><p>a new set of arguments with the described transformations made
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#relaxCollectionMbrTypesToFirstTraitOrAbstractClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="relaxCollectionMbrTypesToFirstTraitOrAbstractClass(argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]):Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]"></a>
      <a id="relaxCollectionMbrTypesToFirstTraitOrAbstractClass(Array[(String,Boolean,BaseTypeDef)]):Array[(String,Boolean,BaseTypeDef)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxCollectionMbrTypesToFirstTraitOrAbstractClass</span><span class="params">(<span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Prepare a new set of argTypes that promote the element types of those ContainerTypeDefs in the argTypes array that
 have them to their respective first trait or abstract class found in its list of superclasses (@see collectCollectionElementSuperClasses).</p><div class="fullcomment"><div class="comment cmt"><p> Prepare a new set of argTypes that promote the element types of those ContainerTypeDefs in the argTypes array that
 have them to their respective first trait or abstract class found in its list of superclasses (@see collectCollectionElementSuperClasses).
 The Collection container for these ContainerTypeDefs remains unchanged.
</p></div><dl class="paramcmts block"><dt class="param">argTypes</dt><dd class="cmt"><p>- the argument type info for a given apply function</p></dd><dt>returns</dt><dd class="cmt"><p>an array of argument types with the container elements' types possibly promoted to their abstract trait.
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#relaxCollectionMbrTypesToReturnType" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="relaxCollectionMbrTypesToReturnType(argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],returnTypes:Array[String]):Array[String]"></a>
      <a id="relaxCollectionMbrTypesToReturnType(Array[(String,Boolean,BaseTypeDef)],Array[String]):Array[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxCollectionMbrTypesToReturnType</span><span class="params">(<span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>, <span name="returnTypes">returnTypes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> When a function has an argument that is an iterable function and that argument was a 'map' function or something
 similar, the receiver array that was used has its type changed to whatever the member function in the map
 returns.</p><div class="fullcomment"><div class="comment cmt"><p> When a function has an argument that is an iterable function and that argument was a 'map' function or something
 similar, the receiver array that was used has its type changed to whatever the member function in the map
 returns.  This return type is captured and included in the returnTypes array.  If there is at least one
 such valid return type in the return types array, this function is called and a new set of arguments is generated
 such that the target argument (a collection) has its element type(s) changed to the corresponding return type.</p><p> Valid values are only populated for these iterable function arguments where type transformation takes place.
 All other cases are set to null
</p></div><dl class="paramcmts block"><dt class="param">argTypes</dt><dd class="cmt"><p>a triple of type information that describes the arguments to the function being considered
 	(type string, isContainerWithFields, the arg metadata)</p></dd><dt class="param">returnTypes</dt><dd class="cmt"><p>when a 'map' function is present the current function's arguments at some position, this
 	array will have the correct type for that argument.  Substitute it.</p></dd><dt>returns</dt><dd class="cmt"><p>a new arguments with the described transformations made
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#relaxIterableKeys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="relaxIterableKeys(doElemFcn:Boolean,iterableFcnName:String,iterableFcnArgs:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],elemFcnName:String,elemFcnArgs:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],containerType:com.ligadata.olep.metadata.ContainerTypeDef,collectionsElementTypes:Array[com.ligadata.olep.metadata.BaseTypeDef],returnTypes:Array[String]):Array[String]"></a>
      <a id="relaxIterableKeys(Boolean,String,Array[(String,Boolean,BaseTypeDef)],String,Array[(String,Boolean,BaseTypeDef)],ContainerTypeDef,Array[BaseTypeDef],Array[String]):Array[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxIterableKeys</span><span class="params">(<span name="doElemFcn">doElemFcn: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="iterableFcnName">iterableFcnName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="iterableFcnArgs">iterableFcnArgs: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>, <span name="elemFcnName">elemFcnName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="elemFcnArgs">elemFcnArgs: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>, <span name="containerType">containerType: <a href="../olep/metadata/ContainerTypeDef.html" class="extype" name="com.ligadata.olep.metadata.ContainerTypeDef">ContainerTypeDef</a></span>, <span name="collectionsElementTypes">collectionsElementTypes: <span class="extype" name="scala.Array">Array</span>[<a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>]</span>, <span name="returnTypes">returnTypes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> If the straight forward search key produced does not produce a FunctionDef, this more
 elaborate mechanism is used to try to relax the argument types.</p><div class="fullcomment"><div class="comment cmt"><p> If the straight forward search key produced does not produce a FunctionDef, this more
 elaborate mechanism is used to try to relax the argument types.
 NOTE: This is a work in progress. First implementation will look for scalar arguments
 of different widths and relax the width iff there are functions with a wider width
 than was proposed in the first key produced.
</p></div></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#relaxReturnedIterableTypeMembers" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="relaxReturnedIterableTypeMembers(argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],returnTypes:Array[String]):Array[String]"></a>
      <a id="relaxReturnedIterableTypeMembers(Array[(String,Boolean,BaseTypeDef)],Array[String]):Array[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxReturnedIterableTypeMembers</span><span class="params">(<span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>, <span name="returnTypes">returnTypes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Similar to function relaxTypesToReturnType, this relaxation checks if the return type is also a
 an 'iterable' container of some sort that has member type(s) that are perhaps too specific.</p><div class="fullcomment"><div class="comment cmt"><p> Similar to function relaxTypesToReturnType, this relaxation checks if the return type is also a
 an 'iterable' container of some sort that has member type(s) that are perhaps too specific.  Relax
 these &quot;too&quot; specific types by replacing them with 'Any'.
</p></div><dl class="paramcmts block"><dt class="param">argTypes</dt><dd class="cmt"><p>a triple of type information that describes the arguments to the function being considered
 	(type string, isContainerWithFields, the arg metadata)</p></dd><dt class="param">returnTypes</dt><dd class="cmt"><p>when a 'map' function is present the current function's arguments at some position, this
 	array will have the correct type for that argument.  Substitute it.</p></dd><dt>returns</dt><dd class="cmt"><p>a new arguments with the described transformations made
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#relaxSimpleKey" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="relaxSimpleKey(fcnName:String,argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],returnTypes:Array[String]):Array[String]"></a>
      <a id="relaxSimpleKey(String,Array[(String,Boolean,BaseTypeDef)],Array[String]):Array[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxSimpleKey</span><span class="params">(<span name="fcnName">fcnName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>, <span name="returnTypes">returnTypes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> If the straight forward search key produced does not produce a FunctionDef, this more
 elaborate mechanism is used to try to relax the argument types.</p><div class="fullcomment"><div class="comment cmt"><p> If the straight forward search key produced does not produce a FunctionDef, this more
 elaborate mechanism is used to try to relax the argument types. Answer an array of
 additional keys to utilize for function type search.</p><p> NOTE: This is a work in progress.</p><p> Current method:
 	relaxation 1)
  			a) If there are collections in the argument list, collect the superclasses
  			for each of their member types that are containers, if any.  Promote their types
     		to the first abstract class or trait found in their respective superclass list.
       		Form a new type with the original outer collection.  Non container types remain
         	unchanged.
          	b) Change the member types to Any keeping the outer collection the same.
           	c) If the returnTypes array has a type or types in it, use it as the member types
     relaxation 2) If there is or more functions by this name that have been marked HAS_INDEFINITE_ARITY,
     		create a function key according to that FunctionDef's type signature.
 	relaxation 3) If there are containers in the argument list, collect the superclasses
  			for each of them, find the first abstract or trait and use it
     relaxation 4) Change containers to Any
     relaxation 5) If there are scalars, broaden their width
     relaxation 6) Make all arguments &quot;Any&quot;
</p></div><dl class="paramcmts block"><dt class="param">fcnName</dt><dd class="cmt"><p>the function' name</p></dd><dt class="param">argTypes</dt><dd class="cmt"><p>the function's argument type info</p></dd><dt class="param">returnTypes</dt><dd class="cmt"><p>if there are any valid type string(s) in it, use them to substitute for the member type(s).  These &quot;return types&quot;
 	are extracted from an argument that uses a map (or similar) function in it that changes the types of the receiver array.  The
  	'map' function is common as it is used to operate on the receiver array content (e.g., summing a number of fields in an array
   	of structures) and therefore changes array's member type to the member function's return type.</p></dd><dt>returns</dt><dd class="cmt"><p>an array of search keys to try that have been configured by one of the relaxation strategies.
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#relaxToFirstTraitOrAbstractClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="relaxToFirstTraitOrAbstractClass(argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]):Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]"></a>
      <a id="relaxToFirstTraitOrAbstractClass(Array[(String,Boolean,BaseTypeDef)]):Array[(String,Boolean,BaseTypeDef)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxToFirstTraitOrAbstractClass</span><span class="params">(<span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Prepare a new set of argTypes that promote the container typedef to their respective abstract class
 superclass or trait.</p><div class="fullcomment"><div class="comment cmt"><p>Prepare a new set of argTypes that promote the container typedef to their respective abstract class
 superclass or trait.  FIXME: Some types have multiple base types that could be used.  The current strategy
 'break's on the first one.  This is not the best.  It should be made to stop on the first appropriate trait
 for the class of type being examined (e.g., &quot;Iterable&quot; or &quot;Traversable&quot;).  This could be implemented by
 mapping the plain function name to the traits that contain that method as an abstract function.
</p></div><dl class="paramcmts block"><dt class="param">argTypes</dt><dd class="cmt"><p>- the argument type info for a given apply function</p></dd><dt>returns</dt><dd class="cmt"><p>an array of argument types with the container types possibly promoted to their abstract trait.
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#relaxTypesToReturnType" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="relaxTypesToReturnType(argTypes:Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],returnTypes:Array[String]):Array[String]"></a>
      <a id="relaxTypesToReturnType(Array[(String,Boolean,BaseTypeDef)],Array[String]):Array[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxTypesToReturnType</span><span class="params">(<span name="argTypes">argTypes: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>, <span name="returnTypes">returnTypes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Substitute the return types collected (there is a return type for any function argument) for the
 corresponding argument type.</p><div class="fullcomment"><div class="comment cmt"><p> Substitute the return types collected (there is a return type for any function argument) for the
 corresponding argument type.
</p></div><dl class="paramcmts block"><dt class="param">argTypes</dt><dd class="cmt"><p>a triple of type information that describes the arguments to the function being considered
 	(type string, isContainerWithFields, the arg metadata)</p></dd><dt class="param">returnTypes</dt><dd class="cmt"><p>a function is present the current function's arguments at some position, this
 	type string will be sustituted in _._1 of the argTypes array.</p></dd><dt>returns</dt><dd class="cmt"><p>a new set of arguments with the described transformations made
</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#representativeFcn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="representativeFcn(name:String):(com.ligadata.olep.metadata.FunctionDef,Boolean)"></a>
      <a id="representativeFcn(String):(FunctionDef,Boolean)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">representativeFcn</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: (<a href="../olep/metadata/FunctionDef.html" class="extype" name="com.ligadata.olep.metadata.FunctionDef">FunctionDef</a>, <span class="extype" name="scala.Boolean">Boolean</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Determine if there is at least one function by this name in the metadata and return one of them
 This gives the caller an idea if this is a standard &quot;simple&quot; function or what is known as an
 &quot;iterable&quot; function.</p><div class="fullcomment"><div class="comment cmt"><p> Determine if there is at least one function by this name in the metadata and return one of them
 This gives the caller an idea if this is a standard &quot;simple&quot; function or what is known as an
 &quot;iterable&quot; function.  Iterable functions have as the name suggests the Iterable trait.  Actually
 the first argument to the function is known as the &quot;receiver&quot; actually has this Iterable trait.</p><p> When one of these is found, the formatting of the function print take forms like these:
 	iterableObj.map(itm =&gt; sum(itm.a, itm.b, itm.c))
  	iterableObj.filter(itm =&gt; between(itm.a,lowbound,hibound,inclusive))</p><p> Were the iterableObject's items &quot;map-based&quot; (as opposed to &quot;fixed&quot;), something like these
 would be generated:
 	iterableObj.map(itm =&gt; sum(itm(a), itm(b), itm(c)))
  	iterableObj.filter(itm =&gt; between(itm(a),lowbound,hibound,inclusive))
</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>of the function(s) sought, possibly namespace qualified)</p></dd><dt>returns</dt><dd class="cmt"><p>if found, the FunctionDef of one (possibly the only) functions with this name and
 	a Boolean that if true says that there is but ONE function by this name (i.e., we're done)</p></dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#selectIterableFcn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="selectIterableFcn:com.ligadata.Compiler.FcnTypeInfo"></a>
      <a id="selectIterableFcn:FcnTypeInfo"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">selectIterableFcn</span><span class="result">: <a href="FcnTypeInfo.html" class="extype" name="com.ligadata.Compiler.FcnTypeInfo">FcnTypeInfo</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Note: When the functions with nmspc.</p><div class="fullcomment"><div class="comment cmt"><p> Note: When the functions with nmspc.name has the ITERABLE feature, there are two searches
 performed:
 	1) for the collection function
  	2) for the element function that operates on the container elements</p></div></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#selectSimpleFcn" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="selectSimpleFcn:com.ligadata.Compiler.FcnTypeInfo"></a>
      <a id="selectSimpleFcn:FcnTypeInfo"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">selectSimpleFcn</span><span class="result">: <a href="FcnTypeInfo.html" class="extype" name="com.ligadata.Compiler.FcnTypeInfo">FcnTypeInfo</a></span>
      </span>
      </h4>
      
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#typeDefsForIterablesFunction" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="typeDefsForIterablesFunction(node:com.ligadata.Compiler.PmmlExecNode,expandCompoundFieldTypes:Boolean,containerType:com.ligadata.olep.metadata.ContainerTypeDef,collectionsElementTypes:Array[com.ligadata.olep.metadata.BaseTypeDef]):Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)]"></a>
      <a id="typeDefsForIterablesFunction(PmmlExecNode,Boolean,ContainerTypeDef,Array[BaseTypeDef]):Array[(String,Boolean,BaseTypeDef)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">typeDefsForIterablesFunction</span><span class="params">(<span name="node">node: <a href="PmmlExecNode.html" class="extype" name="com.ligadata.Compiler.PmmlExecNode">PmmlExecNode</a></span>, <span name="expandCompoundFieldTypes">expandCompoundFieldTypes: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="containerType">containerType: <a href="../olep/metadata/ContainerTypeDef.html" class="extype" name="com.ligadata.olep.metadata.ContainerTypeDef">ContainerTypeDef</a></span>, <span name="collectionsElementTypes">collectionsElementTypes: <span class="extype" name="scala.Array">Array</span>[<a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">This function creates type information for the arguments to the Iterable's member function
 An array is returned of the type information since the simple function treatment does that.</p><div class="fullcomment"><div class="comment cmt"><p>This function creates type information for the arguments to the Iterable's member function
 An array is returned of the type information since the simple function treatment does that.</p><p> Note: For the time being we will not accept xApply types within an iterable function.
 This may be relaxed in the future.</p><p> collectionsElementTypes contain one or more element types. Lists, arrays, sets, and the like
 have one typedef there, maps have two, and tuples could have an arbitrary number of types.</p></div></div>
    </li><li name="com.ligadata.Compiler.FunctionSelect#typeStringFor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="typeStringFor(node:com.ligadata.Compiler.PmmlExecNode,expandCompoundFieldTypes:Boolean):(Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],Array[(String,Boolean,com.ligadata.olep.metadata.BaseTypeDef)],com.ligadata.olep.metadata.ContainerTypeDef,Array[com.ligadata.olep.metadata.BaseTypeDef],String)"></a>
      <a id="typeStringFor(PmmlExecNode,Boolean):(Array[(String,Boolean,BaseTypeDef)],Array[(String,Boolean,BaseTypeDef)],ContainerTypeDef,Array[BaseTypeDef],String)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">typeStringFor</span><span class="params">(<span name="node">node: <a href="PmmlExecNode.html" class="extype" name="com.ligadata.Compiler.PmmlExecNode">PmmlExecNode</a></span>, <span name="expandCompoundFieldTypes">expandCompoundFieldTypes: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: (<span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)], <span class="extype" name="scala.Array">Array</span>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Boolean">Boolean</span>, <a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>)], <a href="../olep/metadata/ContainerTypeDef.html" class="extype" name="com.ligadata.olep.metadata.ContainerTypeDef">ContainerTypeDef</a>, <span class="extype" name="scala.Array">Array</span>[<a href="../olep/metadata/BaseTypeDef.html" class="extype" name="com.ligadata.olep.metadata.BaseTypeDef">BaseTypeDef</a>], <span class="extype" name="scala.Predef.String">String</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Gather type information for the supplied argument node of some function.</p><div class="fullcomment"><div class="comment cmt"><p> Gather type information for the supplied argument node of some function.
 There are three valid cases.  The node is one of:</p><ul><li>An xConstant ... an ordinary constant,</li><li>An xFieldRef ... referring to some field in one of the dictionaries, messages or containers (possibly container qualified),</li><li>An xApply ... a function, possibly an iterable function.</li></ul><p> The function accounts for most of the complexity.  If it is an iterable function, it has two sets of arguments to pack
 out of here to the caller.  All of these types are to be exposed to the printer and type inference tools
 that used to correctly represent the generated output for the function under consideration.
</p></div><dl class="paramcmts block"><dt class="param">node</dt><dd class="cmt"><p>- some PmmlExecNode that can appear in a function argument list</p></dd><dt class="param">expandCompoundFieldTypes</dt><dd class="cmt"><p>this flag causes all type information to be returned for the
 	container qualified field name references.</p></dd><dt>returns</dt><dd class="cmt"><p>(the type info for the outer function, type info for the member function should if appropriate,
 		the container type def for the iterable function's collection if appropriate, the
   		iterable function collection's element type(s) if appropriate, and the return type
     	for the function as needed).
 When not a function, all but the first argument type info is null.  If the arg types have been requested to
 be expanded, these arrays will have more than one member in them to reflect the container types enclosing
 the leaf field.  When no type expansion is requested, just the leaf type info will be in the array.</p><p> When functions, the iterable functions have two type info arrays filled.  Usually the first element of
 the mbr function arguments will be the function's name from the fIdent constant processed, however, even then
 some functions (e.g., map) can do simple projections with no function type.  This is permitted.  At this level
 no discrimination of this issue is considered.  We just pick up arg info here and return it for more complete
 analysis up the call chain.</p><p> Ordinary functions will have just one argument type array filled;  the &quot;mbr&quot; types will be empty.  The return type
 string will be filled for all functions.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="com.ligadata.Compiler.LogTrait">
              <h3>Inherited from <a href="LogTrait.html" class="extype" name="com.ligadata.Compiler.LogTrait">LogTrait</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../../lib/template.js"></script>
    </body>
      </html>